module.exports = (function() {
	/*
	* Generated by PEG.js 0.8.0.
	*
	* http://pegjs.majda.cz/
	*/

	function peg$subclass(child, parent) {
		function ctor() { this.constructor = child; }
		ctor.prototype = parent.prototype;
		child.prototype = new ctor();
	}

	function SyntaxError(message, expected, found, offset, line, column) {
		this.message  = message;
		this.expected = expected;
		this.found    = found;
		this.offset   = offset;
		this.line     = line;
		this.column   = column;

		this.name     = "SyntaxError";
	}

	peg$subclass(SyntaxError, Error);

	function parse(input) {
		var options = arguments.length > 1 ? arguments[1] : {},

		peg$FAILED = {},

		peg$startRuleFunctions = { words: peg$parsewords },
		peg$startRuleFunction  = peg$parsewords,

		peg$c0 = peg$FAILED,
		peg$c1 = [],
		peg$c2 = null,
		peg$c3 = function(e) {return e},
		peg$c4 = function(f, l) {return [f].concat(l);},
		peg$c5 = function() {return text()},
		peg$c6 = /^[A-Z]/,
		peg$c7 = { type: "class", value: "[A-Z]", description: "[A-Z]" },
		peg$c8 = /^[a-z0-9]/,
		peg$c9 = { type: "class", value: "[a-z0-9]", description: "[a-z0-9]" },
		peg$c10 = /^[\t_ ]/,
		peg$c11 = { type: "class", value: "[\\t_ ]", description: "[\\t_ ]" },

		peg$currPos          = 0,
		peg$reportedPos      = 0,
		peg$cachedPos        = 0,
		peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
		peg$maxFailPos       = 0,
		peg$maxFailExpected  = [],
		peg$silentFails      = 0,

		peg$result;

		if ("startRule" in options) {
			if (!(options.startRule in peg$startRuleFunctions)) {
				throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
			}

			peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
		}

		function text() {
			return input.substring(peg$reportedPos, peg$currPos);
		}

		function offset() {
			return peg$reportedPos;
		}

		function line() {
			return peg$computePosDetails(peg$reportedPos).line;
		}

		function column() {
			return peg$computePosDetails(peg$reportedPos).column;
		}

		function expected(description) {
			throw peg$buildException(
				null,
				[{ type: "other", description: description }],
				peg$reportedPos
			);
		}

		function error(message) {
			throw peg$buildException(message, null, peg$reportedPos);
		}

		function peg$computePosDetails(pos) {
			function advance(details, startPos, endPos) {
				var p, ch;

				for (p = startPos; p < endPos; p++) {
					ch = input.charAt(p);
					if (ch === "\n") {
						if (!details.seenCR) { details.line++; }
						details.column = 1;
						details.seenCR = false;
					} else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
						details.line++;
						details.column = 1;
						details.seenCR = true;
					} else {
						details.column++;
						details.seenCR = false;
					}
				}
			}

			if (peg$cachedPos !== pos) {
				if (peg$cachedPos > pos) {
					peg$cachedPos = 0;
					peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
				}
				advance(peg$cachedPosDetails, peg$cachedPos, pos);
				peg$cachedPos = pos;
			}

			return peg$cachedPosDetails;
		}

		function peg$fail(expected) {
			if (peg$currPos < peg$maxFailPos) { return; }

			if (peg$currPos > peg$maxFailPos) {
				peg$maxFailPos = peg$currPos;
				peg$maxFailExpected = [];
			}

			peg$maxFailExpected.push(expected);
		}

		function peg$buildException(message, expected, pos) {
			function cleanupExpected(expected) {
				var i = 1;

				expected.sort(function(a, b) {
					if (a.description < b.description) {
						return -1;
					} else if (a.description > b.description) {
						return 1;
					} else {
						return 0;
					}
				});

				while (i < expected.length) {
					if (expected[i - 1] === expected[i]) {
						expected.splice(i, 1);
					} else {
						i++;
					}
				}
			}

			function buildMessage(expected, found) {
				function stringEscape(s) {
					function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

					return s
					.replace(/\\/g,   '\\\\')
					.replace(/"/g,    '\\"')
					.replace(/\x08/g, '\\b')
					.replace(/\t/g,   '\\t')
					.replace(/\n/g,   '\\n')
					.replace(/\f/g,   '\\f')
					.replace(/\r/g,   '\\r')
					.replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
					.replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
					.replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
					.replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
				}

				var expectedDescs = new Array(expected.length),
				expectedDesc, foundDesc, i;

				for (i = 0; i < expected.length; i++) {
					expectedDescs[i] = expected[i].description;
				}

				expectedDesc = expected.length > 1
				? expectedDescs.slice(0, -1).join(", ")
				+ " or "
				+ expectedDescs[expected.length - 1]
				: expectedDescs[0];

				foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

				return "Expected " + expectedDesc + " but " + foundDesc + " found.";
			}

			var posDetails = peg$computePosDetails(pos),
			found      = pos < input.length ? input.charAt(pos) : null;

			if (expected !== null) {
				cleanupExpected(expected);
			}

			return new SyntaxError(
				message !== null ? message : buildMessage(expected, found),
				expected,
				found,
				pos,
				posDetails.line,
				posDetails.column
			);
		}

		function peg$parsewords() {
			var s0, s1, s2, s3, s4, s5;

			s0 = peg$currPos;
			s1 = peg$parseword();
			if (s1 !== peg$FAILED) {
				s2 = [];
				s3 = peg$currPos;
				s4 = peg$parseWS();
				if (s4 === peg$FAILED) {
					s4 = peg$c2;
				}
				if (s4 !== peg$FAILED) {
					s5 = peg$parseword();
					if (s5 !== peg$FAILED) {
						peg$reportedPos = s3;
						s4 = peg$c3(s5);
						s3 = s4;
					} else {
						peg$currPos = s3;
						s3 = peg$c0;
					}
				} else {
					peg$currPos = s3;
					s3 = peg$c0;
				}
				while (s3 !== peg$FAILED) {
					s2.push(s3);
					s3 = peg$currPos;
					s4 = peg$parseWS();
					if (s4 === peg$FAILED) {
						s4 = peg$c2;
					}
					if (s4 !== peg$FAILED) {
						s5 = peg$parseword();
						if (s5 !== peg$FAILED) {
							peg$reportedPos = s3;
							s4 = peg$c3(s5);
							s3 = s4;
						} else {
							peg$currPos = s3;
							s3 = peg$c0;
						}
					} else {
						peg$currPos = s3;
						s3 = peg$c0;
					}
				}
				if (s2 !== peg$FAILED) {
					peg$reportedPos = s0;
					s1 = peg$c4(s1, s2);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$c0;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$c0;
			}

			return s0;
		}

		function peg$parseword() {
			var s0;

			s0 = peg$parsecappedWord();
			if (s0 === peg$FAILED) {
				s0 = peg$parseplainWord();
			}

			return s0;
		}

		function peg$parsecappedWord() {
			var s0, s1, s2, s3;

			s0 = peg$currPos;
			s1 = [];
			s2 = peg$parseUPPERCASE();
			if (s2 !== peg$FAILED) {
				while (s2 !== peg$FAILED) {
					s1.push(s2);
					s2 = peg$parseUPPERCASE();
				}
			} else {
				s1 = peg$c0;
			}
			if (s1 !== peg$FAILED) {
				s2 = [];
				s3 = peg$parseLOWERCASE();
				while (s3 !== peg$FAILED) {
					s2.push(s3);
					s3 = peg$parseLOWERCASE();
				}
				if (s2 !== peg$FAILED) {
					peg$reportedPos = s0;
					s1 = peg$c5();
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$c0;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$c0;
			}

			return s0;
		}

		function peg$parseplainWord() {
			var s0, s1, s2;

			s0 = peg$currPos;
			s1 = [];
			s2 = peg$parseLOWERCASE();
			if (s2 !== peg$FAILED) {
				while (s2 !== peg$FAILED) {
					s1.push(s2);
					s2 = peg$parseLOWERCASE();
				}
			} else {
				s1 = peg$c0;
			}
			if (s1 !== peg$FAILED) {
				peg$reportedPos = s0;
				s1 = peg$c5();
			}
			s0 = s1;

			return s0;
		}

		function peg$parseUPPERCASE() {
			var s0;

			if (peg$c6.test(input.charAt(peg$currPos))) {
				s0 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c7); }
			}

			return s0;
		}

		function peg$parseLOWERCASE() {
			var s0;

			if (peg$c8.test(input.charAt(peg$currPos))) {
				s0 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s0 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c9); }
			}

			return s0;
		}

		function peg$parseWS() {
			var s0, s1;

			s0 = [];
			if (peg$c10.test(input.charAt(peg$currPos))) {
				s1 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s1 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c11); }
			}
			if (s1 !== peg$FAILED) {
				while (s1 !== peg$FAILED) {
					s0.push(s1);
					if (peg$c10.test(input.charAt(peg$currPos))) {
						s1 = input.charAt(peg$currPos);
						peg$currPos++;
					} else {
						s1 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$c11); }
					}
				}
			} else {
				s0 = peg$c0;
			}

			return s0;
		}

		peg$result = peg$startRuleFunction();

		if (peg$result !== peg$FAILED && peg$currPos === input.length) {
			return peg$result;
		} else {
			if (peg$result !== peg$FAILED && peg$currPos < input.length) {
				peg$fail({ type: "end", description: "end of input" });
			}

			throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
		}
	}

	return {
		SyntaxError: SyntaxError,
		parse:       parse
	};
})();
